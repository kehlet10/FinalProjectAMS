/************************************************************
  File name: "TFTdriver.c"

  Driver for "ITDB02 320 x 240 TFT display module, Version 2"
  mounted at "ITDB02 Arduino Mega2560 Shield".
  Display controller = ILI 9341.
  
  Max. uC clock frequency = 16 MHz (Tclk = 62,5 ns)

  Connections:
  DB15-DB8:   PORT A
  DB7-DB0:    PORT C

  RESETx:     PORT G, bit 0
  CSx:        PORT G, bit 1
  WRx:        PORT G, bit 2
  RS (=D/Cx): PORT D, bit 7

  Henning Hargaard, February 14, 2019
************************************************************/  
#include <avr/io.h> 
#include <avr/cpufunc.h>
#define F_CPU 16000000
#include <util/delay.h>
#include "TFTdriver.h"
#include "UART.h"

// Data port definitions:
#define DATA_PORT_HIGH PORTA
#define DATA_PORT_LOW  PORTC

// Control port definitions:
#define WR_PORT PORTG 
#define WR_BIT 2
#define DC_PORT PORTD
#define DC_BIT  7  //"DC" signal is at the shield called RS
#define CS_PORT PORTG 
#define CS_BIT  1 
#define RST_PORT PORTG
#define RST_BIT 0


//Font Colour

const unsigned short Number_Font[] = { // 24 x 27 = 648/8 = 81 bytes
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00, // Code for char num 46
	0x00,0x06,0x00,0x07,0x00,0x03,0x00,0x03,0x80,0x03,0x80,0x01,0x80,0x01,0xC0,0x01,0xC0,0x00,0xC0,0x00,0xE0,0x00,0x60,0x00,0x60,0x00,0x70,0x00,0x30,0x00,0x30,0x00,0x38,0x00,0x18,0x00,0x18,0x00,0x1C,0x00,0x0C,0x00,0x0C,0x00,0x0E,0x00,0x06,0x00,0x06,0x00,0x07,0x00,0x03,0x00, // Code for char num 47
	0x00,0x00,0xE0,0x03,0xF8,0x0F,0xF8,0x0F,0x3C,0x1E,0x1C,0x1C,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x0E,0x38,0x1C,0x1C,0x3C,0x1E,0xF8,0x0F,0xF8,0x0F,0xE0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 48
	0x00,0x00,0x00,0x03,0x80,0x03,0xC0,0x03,0xF8,0x03,0xF8,0x03,0xF8,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0x80,0x03,0xF8,0x3F,0xF8,0x3F,0xF8,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 49
	0x00,0x00,0xF0,0x07,0xFC,0x0F,0xFC,0x1F,0x0C,0x3C,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x1C,0x00,0x0E,0x00,0x07,0x80,0x03,0xC0,0x01,0xE0,0x00,0x70,0x00,0x38,0x00,0x1C,0x00,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 50
	0x00,0x00,0xF0,0x07,0xFC,0x1F,0xFC,0x1F,0x0C,0x3C,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x0E,0xE0,0x03,0xE0,0x0F,0xE0,0x1F,0x00,0x3C,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x3C,0x06,0x1E,0xFE,0x1F,0xFE,0x0F,0xF8,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 51
	0x00,0x00,0x00,0x1C,0x00,0x1E,0x00,0x1F,0x80,0x1D,0xC0,0x1D,0xE0,0x1C,0x70,0x1C,0x38,0x1C,0x18,0x1C,0x0C,0x1C,0x06,0x1C,0xFE,0xFF,0xFE,0xFF,0xFE,0xFF,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 52
	0x00,0x00,0xF8,0x7F,0xF8,0x7F,0xF8,0x7F,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0x38,0x00,0xF8,0x07,0xF8,0x1F,0xF8,0x3F,0x08,0x7C,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x70,0x00,0x78,0x0C,0x3C,0xFC,0x3F,0xFC,0x1F,0xF0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 53
	0x00,0x00,0x80,0x1F,0xE0,0x1F,0xF0,0x1F,0xF8,0x10,0x38,0x00,0x1C,0x00,0x1C,0x00,0x0E,0x00,0xCE,0x07,0xFE,0x1F,0xFE,0x3F,0x1E,0x7C,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x1C,0x78,0x3C,0x3C,0xF8,0x3F,0xF0,0x1F,0xE0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 54
	0x00,0x00,0xFE,0x3F,0xFE,0x3F,0xFE,0x3F,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x1C,0x00,0x0E,0x00,0x07,0x00,0x07,0x80,0x03,0x80,0x03,0xC0,0x01,0xC0,0x01,0xE0,0x00,0xE0,0x00,0x70,0x00,0x70,0x00,0x38,0x00,0x38,0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 55
	0x00,0x00,0xE0,0x07,0xF0,0x0F,0xF8,0x1F,0x3C,0x3C,0x1C,0x38,0x1C,0x38,0x1C,0x38,0x38,0x18,0xF8,0x1C,0xE0,0x0F,0xF0,0x0F,0x1C,0x3E,0x0C,0x38,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x1E,0x70,0x3C,0x3C,0xFC,0x3F,0xF8,0x1F,0xE0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 56
	0x00,0x00,0xE0,0x07,0xF8,0x0F,0xFC,0x1F,0x3C,0x3C,0x1E,0x38,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x0E,0x70,0x3E,0x78,0xFC,0x7F,0xF8,0x7F,0xE0,0x73,0x00,0x70,0x00,0x38,0x00,0x38,0x00,0x1C,0x08,0x1F,0xF8,0x0F,0xF8,0x07,0xF8,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 57
	0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00, // Code for char num 58
	0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x38,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x38,0x38,0x18,0x1C,0x1C,0x0C,0x0E,0x06, // Code for char num 59
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x80,0x03,0x00,0xE0,0x03,0x00,0xF8,0x00,0x00,0x3E,0x00,0x80,0x0F,0x00,0xC0,0x03,0x00,0xF0,0x00,0x00,0x38,0x00,0x00,0xF0,0x00,0x00,0xC0,0x03,0x00,0x80,0x0F,0x00,0x00,0x3E,0x00,0x00,0xF8,0x00,0x00,0xE0,0x03,0x00,0x80,0x03,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 60
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x07,0xF8,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0xFF,0x07,0xF8,0xFF,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 61
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x38,0x00,0x00,0xF8,0x00,0x00,0xE0,0x03,0x00,0x80,0x0F,0x00,0x00,0x3E,0x00,0x00,0x78,0x00,0x00,0xE0,0x01,0x00,0x80,0x03,0x00,0xE0,0x01,0x00,0x78,0x00,0x00,0x3E,0x00,0x80,0x0F,0x00,0xE0,0x03,0x00,0xF8,0x00,0x00,0x38,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 62
	0x00,0x00,0xF0,0x03,0xFC,0x0F,0xFC,0x0F,0x04,0x1E,0x00,0x1C,0x00,0x1C,0x00,0x1C,0x00,0x0C,0x00,0x0E,0x80,0x07,0xC0,0x03,0xE0,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x60,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 63
	0x00,0x00,0x00,0x00,0xFC,0x01,0x00,0xFF,0x07,0xC0,0x03,0x0E,0xE0,0x00,0x1C,0x70,0x00,0x30,0x30,0xF8,0x73,0x18,0xFE,0x63,0x18,0x87,0x63,0x1C,0x03,0xC3,0x8C,0x01,0xC3,0x8C,0x01,0xC3,0x8C,0x01,0xC3,0x8C,0x01,0xC3,0x8C,0x01,0xC3,0x8C,0x01,0xC3,0x8C,0x03,0xC3,0x18,0xC7,0x63,0x18,0xFE,0x7F,0x30,0x3C,0x3F,0x70,0x00,0x00,0xE0,0x00,0x00,0xC0,0x03,0x02,0x00,0xFF,0x03,0x00,0xFC,0x03,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 64
	0x00,0x00,0x00,0x80,0x03,0x00,0xC0,0x07,0x00,0xC0,0x07,0x00,0xC0,0x07,0x00,0xE0,0x0E,0x00,0xE0,0x0E,0x00,0xE0,0x0E,0x00,0x70,0x1C,0x00,0x70,0x1C,0x00,0x70,0x1C,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0x38,0x38,0x00,0xFC,0x7F,0x00,0xFC,0x7F,0x00,0xFC,0x7F,0x00,0x1E,0xF0,0x00,0x0E,0xE0,0x00,0x0E,0xE0,0x00,0x0F,0xE0,0x01,0x07,0xC0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 65
	0x00,0x00,0xFC,0x0F,0xFC,0x3F,0xFC,0x3F,0x1C,0x78,0x1C,0x70,0x1C,0x70,0x1C,0x70,0x1C,0x30,0x1C,0x38,0xFC,0x1F,0xFC,0x3F,0xFC,0x7F,0x1C,0x70,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0xE0,0x1C,0x78,0xFC,0x7F,0xFC,0x3F,0xFC,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // Code for char num 66
	0x00,0x00,0x80,0x1F,0xE0,0xFF,0xF0,0xFF,0xF8,0xE0,0x3C,0x80,0x1C,0x00,0x1C,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x0E,0x00,0x1E,0x00,0x1C,0x00,0x3C,0x80,0xF8,0xE0,0xF0,0xFF,0xE0,0x7F,0x80,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 // Code for char num 67                                                             // Code for char num 46
};



const unsigned char Number_Font_Start = 0;
const unsigned char Number_Font_Length_Bytes = 81; //Curlz_MT24x33 as shown on Youtube
const unsigned char Number_Font_Width = 24;      // full bytes of pixels   8,16,24 etc
const unsigned char Number_Font_Height = 27;
const unsigned char Number_Font_Spacing = 1;

unsigned int Background_Colour;
unsigned char pixelA;
unsigned char pixelB;
unsigned char pixelC;
unsigned char pixelD;

unsigned char R, G, B;
unsigned char R_back, G_back, B_back;

#define Black_Out         WritePixel(0,0,0);
#define Red_Out           WritePixel(255,0,0);
#define Orange_Out        WritePixel(255,155,0);
#define Yellow_Out        WritePixel(255,255,0);
#define Green_Out         WritePixel(0,255,0);
#define Blue_Out          WritePixel(0,0,255);
#define Violet_Out        WritePixel(196,0,255);
#define Gray_Out          WritePixel(128,128,128);
#define White_Out         WritePixel(255,255,255);
#define Magenta_Out       WritePixel(255,0,255);
#define Lime_Out		  WritePixel(111,255,0);
#define Baby_Powder_Out   WritePixel(141,186,206);
#define Cyan_Out          WritePixel(0,255,255);
#define Lavenderblush_Out WritePixel(255,240,245);
#define Beige_Out         WritePixel(207,185,151);

 unsigned char DoneOne   = 1;
 unsigned char DoneTwo   = 1;
 unsigned char DoneThree = 1;
 unsigned char DoneFour  = 1;
 
 unsigned char  ValidThree = 0, ValidTwo = 0, ValidOne = 0, ValidZero = 0;

// ILI 9341 data sheet, page 238
void WriteCommand(unsigned char command)
{
	
	DATA_PORT_LOW = command; //Data sættes
	
	DC_PORT &= ~(1<<DC_BIT); //DC port er 1 nu sætter vi den lavt - And inverteret
	
	CS_PORT &= ~(1 << CS_BIT); //CSX sættes lavt
	
	WR_PORT &= ~(1 << WR_BIT); //WRX sættes lavt
	
	_NOP();

	WR_PORT |= (1<<WR_BIT);
	
	_NOP();
	
}

// ILI 9341 data sheet, page 238
void WriteData(unsigned int data)
{
	DATA_PORT_HIGH =  data >> 8;
	DATA_PORT_LOW = data; //Data sættes
	
	DC_PORT |= (1<< DC_BIT); //DC port er 1 nu sætter vi den lavt - And inverteret
	
	CS_PORT &= ~(1 << CS_BIT); //CSX sættes lavt
	WR_PORT &= ~(1 << WR_BIT); //WRX sættes lavt
	
	_NOP(); //twr0 > 15 nanosekunder
	
	WR_PORT |= (1 << WR_BIT);
	
	_NOP();
}

// PUBLIC FUNCTIONS ////////////////////////////////////////////////////////////

// Initializes (resets) the display
void DisplayInit()
{
	//Controlpins skal være input
	DDRG |= 0b00000111;
	DDRD |= 0b10000000;
	//Data pins skal være outputs
	DDRA = 0xFF;
	DDRC = 0xFF;
	
	PORTG |= 0b00000111;
	PORTD |= 0b10000000;
	
	RST_PORT &= ~(1<<RST_BIT);
	
	_delay_ms(500);
	
	RST_PORT |= (1<<RST_BIT);
		
	_delay_ms(130);
	
	SleepOut();

	DisplayOn();
	
	
	MemoryAccessControl(0b00001000);
	InterfacePixelFormat(0b00000101);
}

void DisplayOff()
{
	WriteCommand(0x28);
}

void DisplayOn()
{
	
	WriteCommand(0x29);
}

void SleepOut()
{
	WriteCommand(0x11);
}

void MemoryAccessControl(unsigned char parameter)
{
	WriteCommand(0x36);
	WriteData(parameter);
}

void InterfacePixelFormat(unsigned char parameter)
{
	WriteCommand(0x3A);
	WriteData(parameter);
}

void MemoryWrite()
{
	WriteCommand(0x2C);
	
}

// Red 0-31, Green 0-63, Blue 0-31
void WritePixel(unsigned char Red, unsigned char Green, unsigned char Blue)
{
	unsigned int data = 0;
	data |= Red << 11;
	data |= Green << 5;
	data |= Blue;
	
	WriteData(data);
	
}

// Set Column Address (0-239), Start > End
void SetColumnAddress(unsigned int Start, unsigned int End)
{
	WriteCommand(0x2A);
	WriteData(Start >> 8);
	WriteData(Start);
	WriteData(End >> 8);
	WriteData(End);
}

// Set Page Address (0-319), Start > End
void SetPageAddress(unsigned int Start, unsigned int End)
{
	WriteCommand(0x2B);
	WriteData(Start >> 8);
	WriteData(Start);
	WriteData(End >> 8);
	WriteData(End);
	
}

void setDisplayNumberFont(unsigned int X_Position, unsigned int Y_Position)
{
	    unsigned int Set_start_column = 0x00 | X_Position;
	    unsigned int Set_start_row = 0x00 | Y_Position;

	    unsigned int Set_end_column = Set_start_column + Number_Font_Width-1; //(bytes -1 bit) 8 pixels = 1 byte, 16 pixels = 2 bytes
	    unsigned int Set_end_row = Set_start_row + Number_Font_Height;
		
		SetColumnAddress(Set_start_column, Set_end_column);
		
		SetPageAddress(Set_start_row, Set_end_row);

	    WriteCommand(0x2C);
	
}

unsigned int ClearScreen(unsigned char colour)
{
	static long int i;
	Background_Colour = 0x00 | colour;
	
	SetColumnAddress(0, 239);
	SetPageAddress(0, 319);

	WriteCommand(0x2C); //Write Memory Start

	switch (colour)  {

		case 0:     for(i=0;i<76800;i++){
			Black_Out;
		} break;
		case 2:     for(i=0;i<76800;i++){
			Red_Out;
		} break;
		case 3:     for(i=0;i<76800;i++){
			Orange_Out;
		} break;
		case 4:     for(i=0;i<76800;i++){
			Yellow_Out;
		} break;
		case 5:     for(i=0;i<76800;i++){
			Green_Out;
		} break;
		case 6:     for(i=0;i<76800;i++){
			Blue_Out;
		} break;
		case 7:     for(i=0;i<76800;i++){
			Violet_Out;
		} break;
		case 8:     for(i=0;i<76800;i++){
			Gray_Out;
		} break;
		case 9:     for(i=0;i<76800;i++){
			White_Out;
		} break;
		case 10:    for(i=0;i<76800;i++){
			Magenta_Out;
		} break;
		case 11:    for(i=0;i<76800;i++){
			Lime_Out;
		} break;
		case 12:    for(i=0;i<76800;i++){
			Baby_Powder_Out;
		} break;
		case 13:    for(i=0;i<76800;i++){
			Cyan_Out;
		} break;
		case 14:    for(i=0;i<76800;i++){
			Lavenderblush_Out;
		} break;
		case 15:    for(i=0;i<76800;i++){
			Beige_Out;
		} break;
		default:    for(i=0;i<76800;i++){
			Baby_Powder_Out;
		} break;
	}
	return Background_Colour;
}



void Space()
{
	WritePixel(R_back,G_back,B_back);
}

unsigned int setpixelColour(unsigned int Colour)
{
	unsigned int colour = 0x00 | Colour;

	switch (colour)  {

		case 0:     R = 0; G = 0, B = 0;
		break;
		case 2:     R = 255; G = 0, B = 0;
		break;
		case 3:     R = 255; G = 155, B = 0;
		break;
		case 4:     R = 255; G = 255, B = 0;
		break;
		case 5:     R = 0; G = 255, B = 0;
		break;
		case 6:     R = 0; G = 0, B = 255;
		break;
		case 7:     R = 196; G = 0, B = 255;
		break;
		case 8:     R = 128; G = 128, B = 128;
		break;
		case 9:     R = 255; G = 255, B = 255;
		break;
		case 10:    R = 255; G = 0, B = 255;
		break;
		case 11:    R = 111; G = 255, B = 0;
		break;
		case 12:    R = 141; G = 186, B = 206;
		break;
		case 13:    R = 0; G = 255, B = 255;
		break;
		case 14:    R = 255; G = 240, B = 245;
		break;
		case 15:    R = 207; G = 185, B = 151;
		break;
		default:    R = 0; G = 0, B = 0;
		break;
	}

	switch (Background_Colour)  {

		case 0:     R_back = 0; G_back = 0, B_back = 0;
		break;		 
		case 2:     R_back = 255; G_back = 0, B_back = 0;
		break;		 
		case 3:     R_back = 255; G_back = 155, B_back = 0;
		break;		 
		case 4:     R_back = 255; G_back = 255, B_back = 0;
		break;		 
		case 5:     R_back = 0; G_back = 255, B_back = 0;
		break;		 
		case 6:     R_back = 0; G_back = 0, B_back = 255;
		break;		 
		case 7:     R_back = 196; G_back = 0, B_back = 255;
		break;		 
		case 8:     R_back = 128; G_back = 128, B_back = 128;
		break;		 
		case 9:     R_back = 255; G_back = 255, B_back = 255;
		break;		 
		case 10:    R_back = 255; G_back = 0, B_back = 255;
		break;		 
		case 11:    R_back = 111; G_back = 255, B_back = 0;
		break;		 
		case 12:    R_back = 141; G_back = 186, B_back = 206;
		break;		 
		case 13:    R_back = 0; G_back = 255, B_back = 255;
		break;		 
		case 14:    R_back = 255; G_back = 240, B_back = 245;
		break;		 
		case 15:    R_back = 207; G_back = 185, B_back = 151;
		break;		 
		default:    R_back = 0; G_back = 0, B_back = 0;
		break;
	}

	return colour;
	return Background_Colour;
	
}

void WriteSpace(unsigned int X_Position, unsigned int Y_Position)
{
	     unsigned int Colour = Background_Colour;
	     static unsigned int jj=0;

	     setpixelColour(Colour);
	     setDisplayNumberFont(X_Position,Y_Position);
	     CS_PORT &= ~(1 << CS_BIT);

	     for (jj=Number_Font_Length_Bytes*11; jj>Number_Font_Length_Bytes*10; jj--){    //Space

		     WritePixel(R_back,G_back,B_back);
	     }

	     CS_PORT |= ~(1 << CS_BIT);
}

void WriteNumber(unsigned int X_pos, unsigned int Y_pos, unsigned int Colour, int NumberToWrite)
{
		static unsigned char x=0;
		static unsigned char dataout=0;
		static unsigned int i=1;
		static unsigned int jj=0;
		unsigned int Pixel_Colour = 0x00 | Colour;
		
		setpixelColour(Colour);
		setDisplayNumberFont(X_pos,Y_pos);
		if(NumberToWrite == 0)
		{
			for (jj=Number_Font_Length_Bytes; jj>Number_Font_Start; jj--)
			{  
				for (x=0; x<8; x++)
				{
					dataout = Number_Font[jj] &i;
					if (dataout >=1)
					{
						//Number zero
						WritePixel(R,G,B);
					} 
					else
					{
						WritePixel(R_back,G_back,B_back);
					}
						i=i<<1;

						if (i>=256)
						{
							i=1;
						}
				}
			}
		}
		else
		{
			for (jj=Number_Font_Length_Bytes*(NumberToWrite+1); jj>Number_Font_Length_Bytes*NumberToWrite; jj--)
			{    
				for (x=0; x<8; x++){

					dataout = Number_Font[jj] &i;

					if (dataout >=1){
						WritePixel(R,G,B);
					} else
					{
					WritePixel(R_back,G_back,B_back); }

					i=i<<1;

					if (i>=256){
					i=1;}
				}
			}
		}
}
	
	
void WriteNumberFromADC(unsigned int X_Position, unsigned int Y_Position, unsigned int setColour, float num)
{
	unsigned int Font_Width;
	Font_Width = Number_Font_Width + Number_Font_Spacing;
	unsigned int pos1 = X_Position;
	unsigned int pos2 = X_Position + Font_Width;
	unsigned int pos3 = X_Position + Font_Width*2;
	unsigned int pos4 = X_Position + Font_Width*3;
	unsigned int pos5 = X_Position + Font_Width*4;
	unsigned int pos6 = X_Position + Font_Width*5;
	unsigned int pos7 = X_Position + Font_Width*6;
	unsigned int pos8 = X_Position + Font_Width*7;
	unsigned int posDot = X_Position + Font_Width*0.5;
	
	static unsigned char numberstring[6];
	
	

	// === FOR DEBUGGING === //
	char debugMsg[50];
	char debugString[20];
	
	dtostrf(num, 3, 3, numberstring);     // Converts input unsigned long integer number to a string
	sprintf(debugMsg, "WriteNumber is %6s\r\n", numberstring);
	SendString(UART0, debugMsg );

	switch (numberstring[0])  {  //units position

		case 48:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 0);
		break;
		case 49:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 1);
		break;
		case 50:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 2);
		break;
		case 51:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 3);
		break;
		case 52:
		WriteNumber(X_Position,Y_Position, setColour, 4);
		break;
		case 53:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 5);
		break;
		case 54:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 6);
		break;
		case 55:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 7);
		break;
		case 56:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 8);
		break;
		case 57:    X_Position = pos1;
		WriteNumber(X_Position,Y_Position, setColour, 9);
		break;
		default:    break;
	}
	
	WriteNumber(posDot, Y_Position, setColour, 16);
	
	switch (numberstring[2])  {  //units position

		case 48:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 0);
		break;
		case 49:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 1);
		break;
		case 50:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 2);
		break;
		case 51:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 3);
		break;
		case 52:	X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 4);
		break;
		case 53:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 5);
		break;
		case 54:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 6);
		break;
		case 55:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 7);
		break;
		case 56:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 8);
		break;
		case 57:    X_Position = pos2;
		WriteNumber(X_Position,Y_Position, setColour, 9);
		break;
		default:    break;
	}
	
	switch (numberstring[3])  {  //units position

		case 48:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 0);
		break;
		case 49:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 1);
		break;
		case 50:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 2);
		break;
		case 51:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 3);
		break;
		case 52:	X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 4);
		break;
		case 53:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 5);
		break;
		case 54:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 6);
		break;
		case 55:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 7);
		break;
		case 56:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 8);
		break;
		case 57:    X_Position = pos3;
		WriteNumber(X_Position,Y_Position, setColour, 9);
		break;
		default:    break;
	}
	
	switch (numberstring[4])  {  //units position

		case 48:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 0);
		break;
		case 49:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 1);
		break;
		case 50:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 2);
		break;
		case 51:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 3);
		break;
		case 52:	X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 4);
		break;
		case 53:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 5);
		break;
		case 54:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 6);
		break;
		case 55:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 7);
		break;
		case 56:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 8);
		break;
		case 57:    X_Position = pos4;
		WriteNumber(X_Position,Y_Position, setColour, 9);
		break;
		default:    break;
	}
	
		//BAC AFTER
		X_Position = pos5;
		WriteNumber(X_Position , Y_Position, setColour, 13 );
		X_Position = pos6;
		WriteNumber(X_Position , Y_Position, setColour, 14 );
		X_Position = pos7;
		WriteNumber(X_Position , Y_Position, setColour, 15 );
}
